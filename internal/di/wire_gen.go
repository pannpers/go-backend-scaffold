// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package di

import (
	"context"
	"github.com/pannpers/go-backend-scaffold/internal/adapter/connect"
	"github.com/pannpers/go-backend-scaffold/internal/entity"
	"github.com/pannpers/go-backend-scaffold/internal/infrastructure/database/rdb"
	"github.com/pannpers/go-backend-scaffold/internal/infrastructure/server"
	"github.com/pannpers/go-backend-scaffold/internal/usecase"
	"github.com/pannpers/go-backend-scaffold/pkg/config"
	"github.com/pannpers/go-backend-scaffold/pkg/logging"
	"io"
	"log/slog"
	"time"
)

// Injectors from wire.go:

// InitializeApp creates a new App with all dependencies wired up.
func InitializeApp() (*App, error) {
	config, err := provideConfig()
	if err != nil {
		return nil, err
	}
	logger := provideLogger(config)
	database, err := provideDatabase(config, logger)
	if err != nil {
		return nil, err
	}
	userRepository := provideMockUserRepository()
	userUseCase := usecase.NewUserUseCase(userRepository, logger)
	userHandler := connect.NewUserHandler(userUseCase, logger)
	postRepository := provideMockPostRepository()
	postUseCase := usecase.NewPostUseCase(postRepository, logger)
	postHandler := connect.NewPostHandler(postUseCase, logger)
	connectServer := server.NewConnectServer(config, logger, database, userHandler, postHandler)
	app := newApp(connectServer, database)
	return app, nil
}

// wire.go:

func newApp(server2 *server.ConnectServer, db *rdb.Database) *App {
	return &App{
		Server:  server2,
		Closers: []io.Closer{db},
	}
}

// provideConfig creates a new config instance.
func provideConfig() (*config.Config, error) {
	return config.Load("")
}

// provideLogger creates a new logger instance based on config.
func provideLogger(cfg *config.Config) *logging.Logger {
	var opts []logging.Option

	switch cfg.Logging.Level {
	case "debug":
		opts = append(opts, logging.WithLevel(slog.LevelDebug))
	case "info":
		opts = append(opts, logging.WithLevel(slog.LevelInfo))
	case "warn":
		opts = append(opts, logging.WithLevel(slog.LevelWarn))
	case "error":
		opts = append(opts, logging.WithLevel(slog.LevelError))
	}

	switch cfg.Logging.Format {
	case "text":
		opts = append(opts, logging.WithFormat(logging.FormatText))
	case "json":
		opts = append(opts, logging.WithFormat(logging.FormatJSON))
	}

	return logging.New(opts...)
}

// provideDatabase creates a new database instance.
func provideDatabase(cfg *config.Config, logger *logging.Logger) (*rdb.Database, error) {
	return rdb.New(cfg, logger)
}

// MockUserRepository is a simple mock implementation for development
type MockUserRepository struct{}

func (m *MockUserRepository) Create(ctx context.Context, params *entity.NewUser) (*entity.User, error) {
	return &entity.User{
		ID:        "mock-user-id",
		Name:      params.Name,
		Email:     params.Email,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}, nil
}

func (m *MockUserRepository) Get(ctx context.Context, id string) (*entity.User, error) {
	return &entity.User{
		ID:        id,
		Name:      "Mock User",
		Email:     "mock@example.com",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}, nil
}

func (m *MockUserRepository) Delete(ctx context.Context, id string) error {
	return nil
}

// MockPostRepository is a simple mock implementation for development
type MockPostRepository struct{}

func (m *MockPostRepository) Create(ctx context.Context, params *entity.NewPost) (*entity.Post, error) {
	return &entity.Post{
		ID:        "mock-post-id",
		Title:     params.Title,
		UserID:    params.UserID,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}, nil
}

func (m *MockPostRepository) Get(ctx context.Context, id string) (*entity.Post, error) {
	return &entity.Post{
		ID:        id,
		Title:     "Mock Post",
		UserID:    "mock-user-id",
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}, nil
}

func (m *MockPostRepository) Delete(ctx context.Context, id string) error {
	return nil
}

// provideMockUserRepository creates a mock user repository implementation.
// TODO: Replace with actual database implementation
func provideMockUserRepository() entity.UserRepository {
	return &MockUserRepository{}
}

// provideMockPostRepository creates a mock post repository implementation.
// TODO: Replace with actual database implementation
func provideMockPostRepository() entity.PostRepository {
	return &MockPostRepository{}
}
